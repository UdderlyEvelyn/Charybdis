using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Security.Cryptography;
using System.IO;
using System.Diagnostics.CodeAnalysis;

namespace Charybdis.Library.Core
{
    public static class Encryption
    {
        //static Encryption()
        //{
        //    _setKeyProtection(true);
        //}

        //If you change this, all existing data encrypted with this key will not be readable without manually specifying the original key to read it!
        //This should only be changed if we have a security breach and the key becomes insecure, otherwise use the methods that take a key parameter instead.
        private static readonly byte[] _key = { 0x05, 0x04, 0x09, 0x20, 
                                                0x55, 0x92, 0x99, 0x92, 
                                                0x10, 0x31, 0x43, 0x58, 
                                                0x99, 0x91, 0x35, 0x90,
                                                0x04, 0x02, 0x09, 0xE0, 
                                                0x55, 0x92, 0x99, 0x92, 
                                                0x10, 0x30, 0xFF, 0x58, 
                                                0x99, 0x91, 0x35, 0x90 }; //32-byte (256-bit) Key
        
        //[ExcludeFromCodeCoverage] //Don't need to test a variable for code coverage when it just passes another along.
        //public static bool EncryptionKeyProtectionStatus
        //{
        //    get
        //    {
        //        return _keyEncryptionState;
        //    }
        //}

        //private static bool _keyEncryptionPossible = true;
        //private static bool _keyEncryptionState = false;
        ///// <summary>
        ///// Sets the memory holding the static encryption key to be encrypted, minimizing the chance it could be read by malicious code/etc..
        ///// </summary>
        ///// <param name="state"></param>
        //private static void _setKeyProtection(bool state)
        //{
        //    if (_keyEncryptionPossible) //If key encryption is possible..
        //    {
        //        if (_keyEncryptionState != state) //If it isn't already in the state that's been requested..
        //        {
        //            try
        //            {
        //                if (state) //If it's being encrypted..
        //                    ProtectedMemory.Protect(_key, MemoryProtectionScope.SameProcess); //Encrypt the key in memory.
        //                else //If it's being decrypted..
        //                    ProtectedMemory.Unprotect(_key, MemoryProtectionScope.SameProcess); //Decrypt the key in memory.
        //                _keyEncryptionState = state; //Set the state variable to the new state.
        //            }
        //            catch (System.Security.SecurityException) //Problem..
        //            {
        //                //We don't have the required permission to use the data protection in this context, so quietly move along.
        //                _keyEncryptionState = false; //Set it to false since we can't use the encryption.
        //                _keyEncryptionPossible = false; //Set this to false so we don't bother trying again (for performance).
        //            }
        //        }
        //    }
        //}

        /// <summary>
        /// This uses a key to take a string and output a base64-encoded AES-encrypted string.
        /// </summary>
        /// <param name="input">string to encrypt</param>
        /// <param name="encoding">encoding to use to decode the string into bytes</param>
        /// <param name="key">key to use (defaults to an internal-to-the-assembly 256-bit key if not provided)</param>
        /// <returns></returns>   
        /// <exception cref="System.ArgumentNullException"/>
        /// <exception cref="System.Text.EncoderFallbackException"/>
        /// <exception cref="System.Security.Cryptography.CryptographicException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <exception cref="System.OverflowException"/>
        /// <exception cref="System.Security.SecurityException"/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2202:Do not dispose objects multiple times", Justification = "Officially, \"If an object's Dispose method is called more than once, the object must ignore all calls after the first one. The object must not throw an exception if its Dispose method is called multiple times.\"")]
        public static string Encrypt(string input, Encoding encoding, byte[] key = null)
        {
            if (key == null) key = _key;
            using (Aes aes = AesCryptoServiceProvider.Create())
            {
                byte[] bytes = encoding.GetBytes(input);
                aes.GenerateIV(); //Use random IV for every Encrypt call (insecure otherwise, though it could be generated by other random means than this method).
                //_setKeyProtection(false); //Decrypt the key so we can use it.
                using (var enc = aes.CreateEncryptor(key, aes.IV))
                using (var stream = new MemoryStream())
                using (var crypt = new CryptoStream(stream, enc, CryptoStreamMode.Write))
                using (var bw = new BinaryWriter(crypt))
                {
                    bw.Write(bytes);
                    crypt.FlushFinalBlock(); //If this isn't done the buffer/length/etc. of the underlying stream is all zero.
                    bytes = aes.IV.Concat(stream); //Prepend the IV and reassign the result to "bytes".
                }
                //_setKeyProtection(true); //Encrypt the key to protect it.
                return Convert.ToBase64String(bytes);
            }
        }

        /// <summary>
        /// This uses an internal-to-the-assembly 256-bit key to take a string and output a base64-encoded AES-encrypted string.
        /// </summary>
        /// <param name="input">string to encrypt (interpreted as ASCII)</param>
        /// <param name="encoding">encoding to use to decode the string into bytes</param>
        /// <returns></returns>
        /// <exception cref="System.ArgumentNullException"/>
        /// <exception cref="System.Text.EncoderFallbackException"/>
        /// <exception cref="System.Security.Cryptography.CryptographicException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <exception cref="System.OverflowException"/>
        /// <exception cref="System.Security.SecurityException"/>
        public static string Encrypt(string input, Encoding encoding)
        {
            return Encrypt(input, encoding, _key);
        }

        /// <summary>
        /// This uses an internal-to-the-assembly 256-bit key to take a string and output a base64-encoded AES-encrypted string.
        /// </summary>
        /// <param name="input">string to encrypt (interpreted as ASCII)</param>
        /// <returns></returns>
        /// <exception cref="System.ArgumentNullException"/>
        /// <exception cref="System.Text.EncoderFallbackException"/>
        /// <exception cref="System.Security.Cryptography.CryptographicException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <exception cref="System.OverflowException"/>
        /// <exception cref="System.Security.SecurityException"/>
        public static string Encrypt(string input)
        {
            return Encrypt(input, Encoding.ASCII, _key);
        }

        /// <summary>
        /// This uses a key to take a string and output a base64-encoded AES-encrypted string.
        /// </summary>
        /// <param name="input">string to encrypt (interpreted as ASCII)</param>
        /// <param name="key">key to use (defaults to an internal-to-the-assembly 256-bit key if not provided)</param>
        /// <returns></returns>
        /// <exception cref="System.ArgumentNullException"/>
        /// <exception cref="System.Text.EncoderFallbackException"/>
        /// <exception cref="System.Security.Cryptography.CryptographicException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <exception cref="System.OverflowException"/>
        /// <exception cref="System.Security.SecurityException"/>
        public static string Encrypt(string input, byte[] key)
        {
            return Encrypt(input, Encoding.ASCII, key);
        }

        /// <summary>
        /// This uses a key to take a base64-encoded AES-encrypted string and decrypt it to plaintext.
        /// </summary>
        /// <param name="input">base64-encoded AES-encrypted string</param>
        /// <param name="encoding">encoding to use to translate the bytes back into a string</param>
        /// <param name="key">key to use (defaults to an internal-to-the-assembly 256-bit key if not provided)</param>
        /// <returns></returns>
        /// <exception cref="System.Security.Cryptography.CryptographicException"/>
        /// <exception cref="System.ArgumentNullException"/>
        /// <exception cref="System.FormatException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <exception cref="System.OverflowException"/>
        /// <exception cref="System.Security.SecurityException"/>
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2202:Do not dispose objects multiple times", Justification = "Officially, \"If an object's Dispose method is called more than once, the object must ignore all calls after the first one. The object must not throw an exception if its Dispose method is called multiple times.\"")]
        public static string Decrypt(string input, Encoding encoding, byte[] key = null)
        {
            if (key == null) key = _key;
            using (Aes aes = AesCryptoServiceProvider.Create())
            {
                //BlockSize is divided by 8 to get bytes, since it is provided in bits.
                int ivSize = aes.BlockSize / 8; //This should not be hardcoded because we are not requesting a specific AES implementation in the using statement, in the future it could change.
                byte[] bytes = Convert.FromBase64String(input);
                byte[] iv = new byte[ivSize];
                string result;
                bytes.Transfer(iv); //Grab the prepended IV.
                bytes = bytes.Extract(ivSize, bytes.Length - ivSize); //Trim the prepended IV off.
                //_setKeyProtection(false); //Decrypt the key so we can use it.
                using (var dec = aes.CreateDecryptor(key, iv))
                using (var stream = new MemoryStream())
                using (var crypt = new CryptoStream(stream, dec, CryptoStreamMode.Write))
                using (var bw = new BinaryWriter(crypt))
                {
                    bw.Write(bytes);
                    crypt.FlushFinalBlock(); //If this isn't done the buffer/length/etc. of the underlying stream is all zero.
                    result = encoding.GetString(stream);
                }
                //_setKeyProtection(true); //Encrypt the key to protect it.
                return result;
            }
        }

        /// <summary>
        /// This uses an internal-to-the-assembly 256-bit key to take a base64-encoded AES-encrypted string and decrypt it to plaintext.
        /// </summary>
        /// <param name="input">base64-encoded AES-encrypted string (assumed to be ASCII-encoded, also assumed that the internal key was used to encrypt)</param>
        /// <param name="encoding">encoding to use to translate the bytes back into a string</param>
        /// <returns></returns>
        /// <exception cref="System.Security.Cryptography.CryptographicException"/>
        /// <exception cref="System.ArgumentNullException"/>
        /// <exception cref="System.FormatException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <exception cref="System.OverflowException"/>
        /// <exception cref="System.Security.SecurityException"/>
        public static string Decrypt(string input, Encoding encoding)
        {
            return Decrypt(input, encoding, _key);
        }

        /// <summary>
        /// This uses an internal-to-the-assembly 256-bit key to take a base64-encoded AES-encrypted string and decrypt it to plaintext.
        /// </summary>
        /// <param name="input">base64-encoded AES-encrypted string (assumed to be ASCII-encoded, also assumed that the internal key was used to encrypt)</param>
        /// <returns></returns>
        /// <exception cref="System.Security.Cryptography.CryptographicException"/>
        /// <exception cref="System.ArgumentNullException"/>
        /// <exception cref="System.FormatException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <exception cref="System.OverflowException"/>
        /// <exception cref="System.Security.SecurityException"/>
        public static string Decrypt(string input)
        {
            return Decrypt(input, Encoding.ASCII, _key);
        }

        /// <summary>
        /// This uses a key to take a base64-encoded AES-encrypted string and decrypt it to plaintext.
        /// </summary>
        /// <param name="input">base64-encoded AES-encrypted string (assumed to be ASCII-encoded)</param>
        /// <param name="key">key to use (defaults to an internal-to-the-assembly 256-bit key if not provided)</param>
        /// <returns></returns>
        /// <exception cref="System.Security.Cryptography.CryptographicException"/>
        /// <exception cref="System.ArgumentNullException"/>
        /// <exception cref="System.FormatException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <exception cref="System.OverflowException"/>
        /// <exception cref="System.Security.SecurityException"/>
        public static string Decrypt(string input, byte[] key)
        {
            return Decrypt(input, Encoding.ASCII, key);
        }

        /// <summary>
        /// This enum provides a list of supported hash types for the hashing functionality of the encryption library.
        /// </summary>
        public enum HashType
        {
            MD5,
            SHA1,
            SHA256,
            SHA384,
            SHA512,
        }

        /// <summary>
        /// Returns a hash in hexadecimal string format of an input string interpreted as ASCII.
        /// </summary>
        /// <param name="input"></param>
        /// <param name="hashType"></param>
        /// <returns></returns>
        public static string Hash(string input, HashType hashType = HashType.SHA256)
        {
            return Hash(input, Encoding.ASCII, hashType);
        }

        /// <summary>
        /// Returns a hash in hexadecimal string format of an input string interpreted in the specified encoding.
        /// </summary>
        /// <param name="input">string to perform hashing on</param>
        /// <param name="hashType">the type of hash to perform (defaults to SHA256)</param>
        /// <param name="encoding">the encoding to interpret the input string as</param>
        /// <returns>hexadecimal string representation of the requested hash type of the given string</returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.ArgumentNullException"/>
        /// <exception cref="System.Text.EncoderFallbackException"/>
        /// <exception cref="System.ArgumentOutOfRangeException"/>
        /// <exception cref="System.OverflowException"/>
        public static string Hash(string input, Encoding encoding, HashType hashType = HashType.SHA256)
        {
            HashAlgorithm ha;
            switch (hashType)
            {
                case HashType.MD5:
                    ha = new MD5CryptoServiceProvider();
                    break;
                case HashType.SHA1:
                    ha = new SHA1CryptoServiceProvider();
                    break;
                case HashType.SHA256:
                    ha = new SHA256CryptoServiceProvider();
                    break;
                case HashType.SHA384:
                    ha = new SHA384CryptoServiceProvider();
                    break;
                case HashType.SHA512:
                    ha = new SHA512CryptoServiceProvider();
                    break;
                default:
                    return null; //Invalid HashType.
            }
            string hashHex = ha.ComputeHash(encoding.GetBytes(input)).ToHex(); //This runs only if ha isn't null, since default case above returns null and prevents getting here.
            ha.Dispose(); //Doing this instead of a "using" statement because we couldn't use the switch/case if we used a "using" statement.
            return hashHex;
        }
    }
}
