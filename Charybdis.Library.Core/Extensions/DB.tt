<# /*This should be set to Build Action of "Content" and the Custom Tool should be blanked out. */ #>
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Data;
using System.Data.<#= Db#>;
using System.Collections;

namespace Charybdis.Library.Core
{
    /// <summary>
    /// A wrapper around the standard .NET <#= DB#> library with nicer (more modern) syntax and extended functionality.
    /// </summary>
    //This class is generated by a combination of T4, DB.tt included within <#= DB#>.tt - do not edit it directly or your changes will be lost.
    public static partial class <#= Db#>
    {
<# if (DB == "OLE") this.Write("        public const string JET4 = \"Microsoft.Jet.OLEDB.4.0\";\n        public const string ACE = \"Microsoft.ACE.OLEDB.12.0\";\n\n"); #>
<# if (DB == "SQL") this.Write("		public static int ConnectionTimeout = 900;\n"); #>        /// <summary>
        /// Represents an <#= DB#> connection with an object to lock onto to avoid blocking when multithreading.
        /// </summary>
        internal struct _<#= db#>ConnectionWithLock
        {
            public <#= Db#>Connection Connection;
            public object Lock;
            public ulong ConnectionsUsed;

            /// <summary>
            /// Create a new _<#= db#>ConnectionWithLock (ignores the cache and does not add the new one to the cache).
            /// </summary>
            /// <param name="connectionString"></param>
            /// <returns></returns>
            public static _<#= db#>ConnectionWithLock New(string connectionString)
            {
                _<#= db#>ConnectionWithLock <#= prefix#>cwl = new _<#= db#>ConnectionWithLock
                {
                    Connection = new <#= Db#>Connection(connectionString),
                    Lock = new object(),
                    ConnectionsUsed = 1,
                };
                return <#= prefix#>cwl;
            }

            /// <summary>
            /// Get an _<#= db#>ConnectionWithLock for a given connection string (tries to get an existing cached one first, caches any new ones it creates).
            /// </summary>
            /// <param name="connectionString"></param>
            /// <returns></returns>
            public static _<#= db#>ConnectionWithLock Get(string connectionString)
            {
                _<#= db#>ConnectionWithLock <#= prefix#>cwl = _no<#= Db#>ConnectionWithLock;
                if (_connectionCache.ContainsKey(connectionString))
                    <#= prefix#>cwl = _connectionCache[connectionString];
                else
                {
                    <#= prefix#>cwl = _<#= db#>ConnectionWithLock.New(connectionString);
                    _connectionCache.Add(connectionString, <#= prefix#>cwl);
                }
                if (<#= prefix#>cwl.Equals(_no<#= Db#>ConnectionWithLock))
                    throw new Exception("Failure to retrieve or create <#= DB#> connection.");
                else
                {
                    if (<#= prefix#>cwl.Connection == null) //Shouldn't happen - just in case.
                    {
                        <#= prefix#>cwl.Connection = new <#= Db#>Connection(connectionString);
                        <#= prefix#>cwl.Connection.Open();
                        <#= prefix#>cwl.ConnectionsUsed++;
                    }
                    try
                    {
                        if (<#= prefix#>cwl.Connection.State != ConnectionState.Open) //If it isn't open,
                            <#= prefix#>cwl.Connection.Open(); //Make sure it is.
                    }
                    catch (Exception e) //Failed to open?
                    {
                        e.ThrowIfNot<
                            InvalidOperationException,
                            <#= Db#>Exception,
                            System.Configuration.ConfigurationErrorsException
                            >("Failure to re-open existing <#= DB#> connection."); //If it's an odd reason, rethrow.
                        <#= prefix#>cwl.Connection = new <#= Db#>Connection(connectionString);
                        <#= prefix#>cwl.Connection.Open();
                        <#= prefix#>cwl.ConnectionsUsed++;
                    }
                    return <#= prefix#>cwl;
                }
            }
        }

        /// <summary>
        /// Represents a non-entity of the type _<#= db#>ConnectionWithLock.
        /// </summary>
        internal static _<#= db#>ConnectionWithLock _no<#= Db#>ConnectionWithLock = new _<#= db#>ConnectionWithLock { Connection = null, ConnectionsUsed = 0, Lock = null };

        /// <summary>
        /// Returns the connections used so far for a particular connection string.
        /// </summary>
        /// <param name="connectionString"></param>
        /// <returns></returns>
        public static ulong GetConnectionsUsed(string connectionString)
        {
            return _connectionCache[connectionString].ConnectionsUsed;
        }

        /// <summary>
        /// Storage location for connection reuse.
        /// </summary>
        private static Dictionary<string, _<#= db#>ConnectionWithLock> _connectionCache = new Dictionary<string, _<#= db#>ConnectionWithLock>();

        /// <summary>
        /// Represents a set of parameters to be used with an <#= DB#> query.
        /// </summary>
        public class Parameters : Dictionary<string, object>, IDictionary<string, object> {}

        /// <summary>
        /// Returns a Parameters object containing the single name/value combination provided.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <example>
        /// You want to pass a single parameter into a method from this library:
        /// <code>
        /// string fieldNameFromSomewhere = "ID";
        /// <#= Db#>.Execute("select @field from MyTable", connectionStringFromSomewhere, <#= Db#>.Parameter("@field", fieldNameFromSomewhere));
        /// </code>
        /// The way this works is equivalent to doing "new <#= Db#>Parameter(name, value)" with the regular API, except this library does not directly accept the underlying API's objects.
        /// </example>
        public static Parameters Parameter(string name, object value)
        {
            return new Parameters { { name, value } };
        }

        public class CachedObject
        {
            private Dictionary<string, object> _fields = new Dictionary<string, object>();
			public Dictionary<string, object> Fields
			{
				get
				{
					return _fields;
				}
			}

            /// <summary>
            /// Creates a CachedObject from an <#= Db#>DataReader by reading all of the latter's fields into a Dictionary object.
            /// </summary>
            /// <param name="reader"></param>
            /// <exception cref="System.NotSupportedException"/>
            internal CachedObject(<#= Db#>DataReader reader)
            {
                for (int i = 0; i < reader.FieldCount; i++)
                    _fields.Add(reader.GetName(i), reader.GetValue(i));
            }

            /// <summary>
            /// Create a CachedObject from an existing <#= Db#>DataReader - used for interoperability with existing projects using the native <#= DB#> libraries.
            /// </summary>
            /// <param name="reader"></param>
            /// <returns></returns>
            public static CachedObject FromReader(<#= Db#>DataReader reader)
            {
                return new CachedObject(reader);
            }

            /// <summary>
            /// Create list of CachedObject from an existing <#= Db#>DataReader - used for interoperability with existing projects using the native <#= DB#> libraries.
            /// </summary>
            /// <param name="reader"></param>
            /// <returns></returns>
            public static List<CachedObject> ListFromReader(<#= Db#>DataReader reader)
            {
                List<CachedObject> result = new List<CachedObject>();
                while (reader.Read())
                {
                    result.Add(new CachedObject(reader));
                }
                return result;
            }

            /// <summary>
            /// Retrieves a value-typed object from the CachedObject as the provided type.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="key"></param>
            /// <returns></returns>
            /// <exception cref="System.KeyNotFoundException"/>
            /// <example>
            /// Get a string named "LastName" from an object:
            /// <c>string lastName = myCachedObject.GetClass<string>("LastName");</c>
            /// </example>
            public T GetClass<T>(string key)
                where T : class
            {
                try
                {
                    return _fields[key] as T;
                }
                catch (KeyNotFoundException e) //The field isn't part of this object..
                {
                    throw new DataRetrievalException("The column \"" + key + "\" was not found on the object in CachedObject.GetClass<" + typeof(T).Name + ">(\"" + key + "\").", e);
                }
            }

            /// <summary>
            /// Retrieves a nullable struct from the CachedObject as the provided type.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="key"></param>
            /// <returns></returns>
            /// <exception cref="System.KeyNotFoundException"/>
            /// <example>
            /// Get an optional FK ID named "ResultID":
            /// <c>int? resultID = myCachedObject.GetNullable<int?>("ResultID");</c>
            /// </example>
            public T? GetNullable<T>(string key)
                where T : struct
            {
                try
                {
                    if (_fields[key] != DBNull.Value)
                        return (T)_fields[key];
                    else
                        return null;
                }
                catch (InvalidCastException) //The value isn't valid..
                {
                    return null;
                }
                catch (KeyNotFoundException e) //The field isn't part of this object..
                {
                    throw new DataRetrievalException("The column \"" + key + "\" was not found on the object in CachedObject.GetNullable<" + typeof(T).Name + ">(\"" + key + "\").", e);
                }
            }

            /// <summary>
            /// Retrieves a struct from the CachedObject as the provided type.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="key"></param>
            /// <returns></returns>
            /// <exception cref="System.KeyNotFoundException"/>
            /// <exception cref="System.InvalidCastException"/>
            /// <example>
            /// Get a PK named "ID" from an object:
            /// <c>int objectID = myCachedObject.GetStruct<int>("ID");</c>
            /// </example>
            public T GetStruct<T>(string key)
                where T : struct
            {
                try
                {
                    return (T)_fields[key];
                }
                catch (KeyNotFoundException e) //The field isn't part of this object..
                {
                    throw new DataRetrievalException("The column \"" + key + "\" was not found on the object in CachedObject.GetStruct<" + typeof(T).Name + ">(\"" + key + "\").", e);
                }
            }
        }

        //The below version of CachedObject uses a variation of a hackish trick found at 
        //https://codeblog.jonskeet.uk/2010/11/02/evil-code-overload-resolution-workaround/
        //it works and makes the API nicer, but it's bad practice stuff so I decided not
        //to use it in the name of readability and maintainability. -JDS 9/9/16

        /*
        //This wrapper extension method is public, but leads to one of three static methods in CachedObject and its base (compile-time overload resolution).
        public static T Get<T>(this CachedObject co, string name)
        {
            return co.Get<T>(name);
        }

        public class CachedObject : _cachedObjectBase
        {
            public CachedObject(<#= Db#>DataReader reader) : base(reader) {}

            //Class
            public class _classConstraint<T> where T : class { }
            internal T Get<T>(string key, _classConstraint<T> overloadTrickeryIgnoreThis = default(_classConstraint<T>))
                where T : class
            {
                return _fields[key] as T;
            }


            //Struct
            internal T Get<T>(string key, T? overloadTrickeryIgnoreThis = default(T?))
                where T : struct
            {
                return (T)_fields[key];
            }
        }

        public class _cachedObjectBase
        {
            protected Dictionary<string, object> _fields = new Dictionary<string, object>();
            internal _cachedObjectBase(<#= Db#>DataReader reader)
            {
                for (int i = 0; i < reader.FieldCount; i++)
                    _fields.Add(reader.GetName(i), reader.GetValue(i));
            }

            //Nullable Struct
            internal T Get<T>(string key)
            {
                try
                {
                    return (T)_fields[key];
                }
                catch (InvalidCastException) //The value isn't valid..
                {
                    return default(T);
                }
            }
        }*/

        /// <summary>
        /// Convenience wrapper for AddWithParameter that adds the ability to specify <#= DbType#> for the parameter.
        /// </summary>
        /// <param name="collection"></param>
        /// <param name="name"></param>
        /// <param name="value"></param>
        /// <param name="<#= DbType#>"></param>
        /// <returns></returns>
        internal static <#= Db#>Parameter AddWithValue(this <#= Db#>ParameterCollection collection, string name, object value, <#= DbType#> dbType)
        {
            <#= Db#>Parameter parameter = collection.AddWithValue(name, value);
            parameter.<#= DbType#> = dbType;
            return parameter;
        }

        /// <summary>
        /// Fluent-style addition of parameters to an <#= Db#>Command
        /// </summary>
        /// <param name="command"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        internal static <#= Db#>Command WithParameters(this <#= Db#>Command command, Parameters parameters)
        {
            if (parameters != null)
                foreach (var p in parameters)
                    command.Parameters.AddWithValue(p.Key, p.Value ?? DBNull.Value);
            return command;
        }

        /// <summary>
        /// Returns a cached copy of an object retrieved from a query (takes the first object returned if multiple are found).
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="<#= db#>"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.<#= Db#>Client.<#= Db#>Exception"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// Get the first user in a "User" table with an "ID" field for PK that starts at 1.
        /// <c>CachedObject user = <#= Db#>.ExecuteObject("select top 1 from [User] where ID = 1", connectionStringFromSomewhere);</c>
        /// You can then access the user object's fields with the CachedObject class's methods regardless of whether the original connection has closed/etc..
        /// </example>
        //No vulnerability here, the "<#= db#>" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review <#= DB#> queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static CachedObject ExecuteObject(string cmdText, string connectionString, Parameters parameters = null)
        {
            CachedObject result = null;
            _<#= db#>ConnectionWithLock <#= prefix#>cwl = _<#= db#>ConnectionWithLock.Get(connectionString);
            <#= Db#>Connection c = <#= prefix#>cwl.Connection;
            lock (<#= prefix#>cwl.Lock)
            {
                using (<#= Db#>Command cmd = new <#= Db#>Command(cmdText, c).WithParameters(parameters))
                {
                    var reader = cmd.ExecuteReader();
                    //Load first row - set up a result if it exists.
                    if (reader.Read())
                        result = new CachedObject(reader);
                    reader.Close();
                }
                return result;
            }
        }

        /// <summary>
        /// Returns a string containing the results of the query in a format delimited by '\n' for each record, ',' for each column, and '☼' to separate column data.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="<#= db#>"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.<#= Db#>Client.<#= Db#>Exception"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// <code>
        /// var results = <#= Db#>.ExecuteString("select * from User where @activeTableName = @activeID", connectionStringFromSomewhere, 
        ///                               new Parameters
        ///                               {
        ///                                   { "@activeID", 1 }
        ///                                   { "@activeTableName", "LU_Active" }
        ///                               });
        /// </code>
        /// This would return a list of CachedObjects that contained the active users given that you had a lookup table called "LU_Active" with an ID of 1 meaning "active".
        /// </example>
        //No vulnerability here, the "<#= db#>" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review <#= DB#> queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static string ExecuteString(string cmdText, string connectionString, Parameters parameters = null)
        {
			StringBuilder sb = new StringBuilder();
            _<#= db#>ConnectionWithLock <#= prefix#>cwl = _<#= db#>ConnectionWithLock.Get(connectionString);
            <#= Db#>Connection c = <#= prefix#>cwl.Connection;
            lock (<#= prefix#>cwl.Lock)
            {
                using (<#= Db#>Command cmd = new <#= Db#>Command(cmdText, c).WithParameters(parameters))
                {
                    var reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
						for (int i = 0; i < reader.FieldCount; i++)
						{
							var value = reader.GetValue(i);
							sb.Append(reader.GetName(i) + '☼' + value + '☼' + value.GetType().FullName + (i == reader.FieldCount ? '\n' : ','));
						}
                    }
                    reader.Close();
                }
            }
            return sb.ToString();
        }

        /// <summary>
        /// Returns a list of cached copies of objects retrieved from a query.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="<#= db#>"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.<#= Db#>Client.<#= Db#>Exception"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// <code>
        /// var results = <#= Db#>.ExecuteList("select * from User where @activeTableName = @activeID", connectionStringFromSomewhere, 
        ///                               new Parameters
        ///                               {
        ///                                   { "@activeID", 1 }
        ///                                   { "@activeTableName", "LU_Active" }
        ///                               });
        /// </code>
        /// This would return a list of CachedObjects that contained the active users given that you had a lookup table called "LU_Active" with an ID of 1 meaning "active".
        /// </example>
        //No vulnerability here, the "<#= db#>" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review <#= DB#> queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static List<CachedObject> ExecuteList(string cmdText, string connectionString, Parameters parameters = null)
        {
            List<CachedObject> results = new List<CachedObject>();
            _<#= db#>ConnectionWithLock <#= prefix#>cwl = _<#= db#>ConnectionWithLock.Get(connectionString);
            <#= Db#>Connection c = <#= prefix#>cwl.Connection;
            lock (<#= prefix#>cwl.Lock)
            {
                using (<#= Db#>Command cmd = new <#= Db#>Command(cmdText, c).WithParameters(parameters))
                {
                    var reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
                        results.Add(new CachedObject(reader));
                    }
                    reader.Close();
                }
            }
            return results;
        }

        /// <summary>
        /// Performs a non-query operation.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="<#= db#>"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.<#= Db#>Client.<#= Db#>Exception"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// You want to reseed MYTABLE to 1 using a parameter since this might be called many times with different values and you want the server to reuse execution plans.
        /// <c><#= Db#>.ExecuteNonQuery("DBCC CHECKIDENT ('MYTABLE', RESEED, @value)", connectionStringFromSomewhere, <#= Db#>.Parameter("@value", 1));</c>
        /// </example>
        //No vulnerability here, the "<#= db#>" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review <#= DB#> queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static int ExecuteNonQuery(string cmdText, string connectionString, Parameters parameters = null, <#= Db#>Transaction transaction = null)
        {
            _<#= db#>ConnectionWithLock <#= prefix#>cwl = _<#= db#>ConnectionWithLock.Get(connectionString);
            <#= Db#>Connection c = <#= prefix#>cwl.Connection;
            lock (<#= prefix#>cwl.Lock)
            {
                using (<#= Db#>Command cmd = new <#= Db#>Command(cmdText, c).WithParameters(parameters))
                {
					if (transaction != null)
						cmd.Transaction = transaction;
                    return cmd.ExecuteNonQuery();
                }
            }
        }

        /// <summary>
        /// Executes a query and returns the result. If the result is not a single column/row it selects the first column of the first row.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="<#= db#>"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.<#= Db#>Client.<#= Db#>Exception"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// Get Vinh's user ID given a table called "User" with an int PK named "ID":
        /// <c>int vinhID = <#= Db#>.ExecuteScalar<int>("select ID from [User] where FirstName = 'Vinh' and LastName = 'Lam'", connectionStringFromSomewhere);</c>
        /// vinhID would contain Vinh's ID.
        /// </example>
        //No vulnerability here, the "<#= db#>" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review <#= DB#> queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static T ExecuteScalar<T>(string cmdText, string connectionString, Parameters parameters = null)
        {
            _<#= db#>ConnectionWithLock <#= prefix#>cwl = _<#= db#>ConnectionWithLock.Get(connectionString);
            <#= Db#>Connection c = <#= prefix#>cwl.Connection;
            lock (<#= prefix#>cwl.Lock)
            {
                using (<#= Db#>Command cmd = new <#= Db#>Command(cmdText, c).WithParameters(parameters))
                {
                    return (T)cmd.ExecuteScalar();
                }
            }
        }
        public static bool TestConnection(string connectionString)
        {
            _<#= db#>ConnectionWithLock <#= prefix#>cwl = _<#= db#>ConnectionWithLock.Get(connectionString);
            <#= Db#>Connection c = <#= prefix#>cwl.Connection;
            lock (<#= prefix#>cwl.Lock)
            {
                try
                {
                    if (c.State == ConnectionState.Closed)
                        c.Open();
                }
                catch (Exception e)
                {
                    e.ThrowIfNot<InvalidOperationException, <#= Db#>Exception>("Unexpected failure testing <#= DB#> connection.");
                    return false;
                }
                return true;
            }
        }

		public static class Interop
		{
			/// <summary>
			/// Returns a <#= Db#>Parameter object for the single name/value combination provided.
			/// </summary>
			/// <param name="name"></param>
			/// <param name="value"></param>
			/// <returns></returns>
			public static <#= Db#>Parameter Parameter(string name, object value)
			{
				return new <#= Db#>Parameter(name, value);
			}

			public static <#= Db#>DataReader GetReader(string connectionString, string command, Parameters parameters = null)
			{
				_<#= db#>ConnectionWithLock <#= prefix#>cwl = _<#= db#>ConnectionWithLock.Get(connectionString);
				<#= Db#>Connection c = <#= prefix#>cwl.Connection;
				lock (<#= prefix#>cwl.Lock)
				{
					using (<#= Db#>Command cmd = new <#= Db#>Command(command, c).WithParameters(parameters))
					{
						return cmd.ExecuteReader();
					}
				}
			}

			public static <#= Db#>Connection GetConnection(string connectionString)
			{
				return _<#= db#>ConnectionWithLock.Get(connectionString).Connection;
			}
		}
    }
}
