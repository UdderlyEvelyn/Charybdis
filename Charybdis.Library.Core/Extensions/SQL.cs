using System.Data.SqlClient;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Data;
using System.Data.Sql;
using System.Collections;

namespace Charybdis.Library.Core
{
    /// <summary>
    /// A wrapper around the standard .NET SQL library with nicer (more modern) syntax and extended functionality.
    /// </summary>
    //This class is generated by a combination of T4, DB.tt included within SQL.tt - do not edit it directly or your changes will be lost.
    public static partial class Sql
    {
		public static int ConnectionTimeout = 900;
        /// <summary>
        /// Represents an SQL connection with an object to lock onto to avoid blocking when multithreading.
        /// </summary>
        internal struct _sqlConnectionWithLock
        {
            public SqlConnection Connection;
            public object Lock;
            public ulong ConnectionsUsed;

            /// <summary>
            /// Create a new _sqlConnectionWithLock (ignores the cache and does not add the new one to the cache).
            /// </summary>
            /// <param name="connectionString"></param>
            /// <returns></returns>
            public static _sqlConnectionWithLock New(string connectionString)
            {
                _sqlConnectionWithLock scwl = new _sqlConnectionWithLock
                {
                    Connection = new SqlConnection(connectionString),
                    Lock = new object(),
                    ConnectionsUsed = 1,
                };
                return scwl;
            }

            /// <summary>
            /// Get an _sqlConnectionWithLock for a given connection string (tries to get an existing cached one first, caches any new ones it creates).
            /// </summary>
            /// <param name="connectionString"></param>
            /// <returns></returns>
            public static _sqlConnectionWithLock Get(string connectionString)
            {
                _sqlConnectionWithLock scwl = _noSqlConnectionWithLock;
                if (_connectionCache.ContainsKey(connectionString))
                    scwl = _connectionCache[connectionString];
                else
                {
                    scwl = _sqlConnectionWithLock.New(connectionString);
                    _connectionCache.Add(connectionString, scwl);
                }
                if (scwl.Equals(_noSqlConnectionWithLock))
                    throw new Exception("Failure to retrieve or create SQL connection.");
                else
                {
                    if (scwl.Connection == null) //Shouldn't happen - just in case.
                    {
                        scwl.Connection = new SqlConnection(connectionString);
                        scwl.Connection.Open();
                        scwl.ConnectionsUsed++;
                    }
                    try
                    {
                        if (scwl.Connection.State != ConnectionState.Open) //If it isn't open,
                            scwl.Connection.Open(); //Make sure it is.
                    }
                    catch (Exception e) //Failed to open?
                    {
                        e.ThrowIfNot<
                            InvalidOperationException,
                            SqlException,
                            System.Configuration.ConfigurationErrorsException
                            >("Failure to re-open existing SQL connection."); //If it's an odd reason, rethrow.
                        scwl.Connection = new SqlConnection(connectionString);
                        scwl.Connection.Open();
                        scwl.ConnectionsUsed++;
                    }
                    return scwl;
                }
            }
        }

        /// <summary>
        /// Represents a non-entity of the type _sqlConnectionWithLock.
        /// </summary>
        internal static _sqlConnectionWithLock _noSqlConnectionWithLock = new _sqlConnectionWithLock { Connection = null, ConnectionsUsed = 0, Lock = null };

        /// <summary>
        /// Returns the connections used so far for a particular connection string.
        /// </summary>
        /// <param name="connectionString"></param>
        /// <returns></returns>
        public static ulong GetConnectionsUsed(string connectionString)
        {
            return _connectionCache[connectionString].ConnectionsUsed;
        }

        /// <summary>
        /// Storage location for connection reuse.
        /// </summary>
        private static Dictionary<string, _sqlConnectionWithLock> _connectionCache = new Dictionary<string, _sqlConnectionWithLock>();

        /// <summary>
        /// Represents a set of parameters to be used with an SQL query.
        /// </summary>
        public class Parameters : Dictionary<string, object>, IDictionary<string, object> {}

        /// <summary>
        /// Returns a Parameters object containing the single name/value combination provided.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <example>
        /// You want to pass a single parameter into a method from this library:
        /// <code>
        /// string fieldNameFromSomewhere = "ID";
        /// Sql.Execute("select @field from MyTable", connectionStringFromSomewhere, Sql.Parameter("@field", fieldNameFromSomewhere));
        /// </code>
        /// The way this works is equivalent to doing "new SqlParameter(name, value)" with the regular API, except this library does not directly accept the underlying API's objects.
        /// </example>
        public static Parameters Parameter(string name, object value)
        {
            return new Parameters { { name, value } };
        }

        public class CachedObject
        {
            private Dictionary<string, object> _fields = new Dictionary<string, object>();
			public Dictionary<string, object> Fields
			{
				get
				{
					return _fields;
				}
			}

            /// <summary>
            /// Creates a CachedObject from an SqlDataReader by reading all of the latter's fields into a Dictionary object.
            /// </summary>
            /// <param name="reader"></param>
            /// <exception cref="System.NotSupportedException"/>
            internal CachedObject(SqlDataReader reader)
            {
                for (int i = 0; i < reader.FieldCount; i++)
                    _fields.Add(reader.GetName(i), reader.GetValue(i));
            }

            /// <summary>
            /// Create a CachedObject from an existing SqlDataReader - used for interoperability with existing projects using the native SQL libraries.
            /// </summary>
            /// <param name="reader"></param>
            /// <returns></returns>
            public static CachedObject FromReader(SqlDataReader reader)
            {
                return new CachedObject(reader);
            }

            /// <summary>
            /// Create list of CachedObject from an existing SqlDataReader - used for interoperability with existing projects using the native SQL libraries.
            /// </summary>
            /// <param name="reader"></param>
            /// <returns></returns>
            public static List<CachedObject> ListFromReader(SqlDataReader reader)
            {
                List<CachedObject> result = new List<CachedObject>();
                while (reader.Read())
                {
                    result.Add(new CachedObject(reader));
                }
                return result;
            }

            /// <summary>
            /// Retrieves a value-typed object from the CachedObject as the provided type.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="key"></param>
            /// <returns></returns>
            /// <exception cref="System.KeyNotFoundException"/>
            /// <example>
            /// Get a string named "LastName" from an object:
            /// <c>string lastName = myCachedObject.GetClass<string>("LastName");</c>
            /// </example>
            public T GetClass<T>(string key)
                where T : class
            {
                try
                {
                    return _fields[key] as T;
                }
                catch (KeyNotFoundException e) //The field isn't part of this object..
                {
                    throw new DataRetrievalException("The column \"" + key + "\" was not found on the object in CachedObject.GetClass<" + typeof(T).Name + ">(\"" + key + "\").", e);
                }
            }

            /// <summary>
            /// Retrieves a nullable struct from the CachedObject as the provided type.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="key"></param>
            /// <returns></returns>
            /// <exception cref="System.KeyNotFoundException"/>
            /// <example>
            /// Get an optional FK ID named "ResultID":
            /// <c>int? resultID = myCachedObject.GetNullable<int?>("ResultID");</c>
            /// </example>
            public T? GetNullable<T>(string key)
                where T : struct
            {
                try
                {
                    if (_fields[key] != DBNull.Value)
                        return (T)_fields[key];
                    else
                        return null;
                }
                catch (InvalidCastException) //The value isn't valid..
                {
                    return null;
                }
                catch (KeyNotFoundException e) //The field isn't part of this object..
                {
                    throw new DataRetrievalException("The column \"" + key + "\" was not found on the object in CachedObject.GetNullable<" + typeof(T).Name + ">(\"" + key + "\").", e);
                }
            }

            /// <summary>
            /// Retrieves a struct from the CachedObject as the provided type.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="key"></param>
            /// <returns></returns>
            /// <exception cref="System.KeyNotFoundException"/>
            /// <exception cref="System.InvalidCastException"/>
            /// <example>
            /// Get a PK named "ID" from an object:
            /// <c>int objectID = myCachedObject.GetStruct<int>("ID");</c>
            /// </example>
            public T GetStruct<T>(string key)
                where T : struct
            {
                try
                {
                    return (T)_fields[key];
                }
                catch (KeyNotFoundException e) //The field isn't part of this object..
                {
                    throw new DataRetrievalException("The column \"" + key + "\" was not found on the object in CachedObject.GetStruct<" + typeof(T).Name + ">(\"" + key + "\").", e);
                }
            }
        }

        //The below version of CachedObject uses a variation of a hackish trick found at 
        //https://codeblog.jonskeet.uk/2010/11/02/evil-code-overload-resolution-workaround/
        //it works and makes the API nicer, but it's bad practice stuff so I decided not
        //to use it in the name of readability and maintainability. -JDS 9/9/16

        /*
        //This wrapper extension method is public, but leads to one of three static methods in CachedObject and its base (compile-time overload resolution).
        public static T Get<T>(this CachedObject co, string name)
        {
            return co.Get<T>(name);
        }

        public class CachedObject : _cachedObjectBase
        {
            public CachedObject(SqlDataReader reader) : base(reader) {}

            //Class
            public class _classConstraint<T> where T : class { }
            internal T Get<T>(string key, _classConstraint<T> overloadTrickeryIgnoreThis = default(_classConstraint<T>))
                where T : class
            {
                return _fields[key] as T;
            }


            //Struct
            internal T Get<T>(string key, T? overloadTrickeryIgnoreThis = default(T?))
                where T : struct
            {
                return (T)_fields[key];
            }
        }

        public class _cachedObjectBase
        {
            protected Dictionary<string, object> _fields = new Dictionary<string, object>();
            internal _cachedObjectBase(SqlDataReader reader)
            {
                for (int i = 0; i < reader.FieldCount; i++)
                    _fields.Add(reader.GetName(i), reader.GetValue(i));
            }

            //Nullable Struct
            internal T Get<T>(string key)
            {
                try
                {
                    return (T)_fields[key];
                }
                catch (InvalidCastException) //The value isn't valid..
                {
                    return default(T);
                }
            }
        }*/

        /// <summary>
        /// Convenience wrapper for AddWithParameter that adds the ability to specify SqlDbType for the parameter.
        /// </summary>
        /// <param name="collection"></param>
        /// <param name="name"></param>
        /// <param name="value"></param>
        /// <param name="SqlDbType"></param>
        /// <returns></returns>
        internal static SqlParameter AddWithValue(this SqlParameterCollection collection, string name, object value, SqlDbType dbType)
        {
            SqlParameter parameter = collection.AddWithValue(name, value);
            parameter.SqlDbType = dbType;
            return parameter;
        }

        /// <summary>
        /// Fluent-style addition of parameters to an SqlCommand
        /// </summary>
        /// <param name="command"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        internal static SqlCommand WithParameters(this SqlCommand command, Parameters parameters)
        {
            if (parameters != null)
                foreach (var p in parameters)
                    command.Parameters.AddWithValue(p.Key, p.Value ?? DBNull.Value);
            return command;
        }

        /// <summary>
        /// Returns a cached copy of an object retrieved from a query (takes the first object returned if multiple are found).
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="sql"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.SqlClient.SqlException"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// Get the first user in a "User" table with an "ID" field for PK that starts at 1.
        /// <c>CachedObject user = Sql.ExecuteObject("select top 1 from [User] where ID = 1", connectionStringFromSomewhere);</c>
        /// You can then access the user object's fields with the CachedObject class's methods regardless of whether the original connection has closed/etc..
        /// </example>
        //No vulnerability here, the "sql" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review SQL queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static CachedObject ExecuteObject(string cmdText, string connectionString, Parameters parameters = null)
        {
            CachedObject result = null;
            _sqlConnectionWithLock scwl = _sqlConnectionWithLock.Get(connectionString);
            SqlConnection c = scwl.Connection;
            lock (scwl.Lock)
            {
                using (SqlCommand cmd = new SqlCommand(cmdText, c).WithParameters(parameters))
                {
                    var reader = cmd.ExecuteReader();
                    //Load first row - set up a result if it exists.
                    if (reader.Read())
                        result = new CachedObject(reader);
                    reader.Close();
                }
                return result;
            }
        }

        /// <summary>
        /// Returns a string containing the results of the query in a format delimited by '\n' for each record, ',' for each column, and '☼' to separate column data.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="sql"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.SqlClient.SqlException"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// <code>
        /// var results = Sql.ExecuteString("select * from User where @activeTableName = @activeID", connectionStringFromSomewhere, 
        ///                               new Parameters
        ///                               {
        ///                                   { "@activeID", 1 }
        ///                                   { "@activeTableName", "LU_Active" }
        ///                               });
        /// </code>
        /// This would return a list of CachedObjects that contained the active users given that you had a lookup table called "LU_Active" with an ID of 1 meaning "active".
        /// </example>
        //No vulnerability here, the "sql" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review SQL queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static string ExecuteString(string cmdText, string connectionString, Parameters parameters = null)
        {
			StringBuilder sb = new StringBuilder();
            _sqlConnectionWithLock scwl = _sqlConnectionWithLock.Get(connectionString);
            SqlConnection c = scwl.Connection;
            lock (scwl.Lock)
            {
                using (SqlCommand cmd = new SqlCommand(cmdText, c).WithParameters(parameters))
                {
                    var reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
						for (int i = 0; i < reader.FieldCount; i++)
						{
							var value = reader.GetValue(i);
							sb.Append(reader.GetName(i) + '☼' + value + '☼' + value.GetType().FullName + (i == reader.FieldCount ? '\n' : ','));
						}
                    }
                    reader.Close();
                }
            }
            return sb.ToString();
        }

        /// <summary>
        /// Returns a list of cached copies of objects retrieved from a query.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="sql"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.SqlClient.SqlException"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// <code>
        /// var results = Sql.ExecuteList("select * from User where @activeTableName = @activeID", connectionStringFromSomewhere, 
        ///                               new Parameters
        ///                               {
        ///                                   { "@activeID", 1 }
        ///                                   { "@activeTableName", "LU_Active" }
        ///                               });
        /// </code>
        /// This would return a list of CachedObjects that contained the active users given that you had a lookup table called "LU_Active" with an ID of 1 meaning "active".
        /// </example>
        //No vulnerability here, the "sql" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review SQL queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static List<CachedObject> ExecuteList(string cmdText, string connectionString, Parameters parameters = null)
        {
            List<CachedObject> results = new List<CachedObject>();
            _sqlConnectionWithLock scwl = _sqlConnectionWithLock.Get(connectionString);
            SqlConnection c = scwl.Connection;
            lock (scwl.Lock)
            {
                using (SqlCommand cmd = new SqlCommand(cmdText, c).WithParameters(parameters))
                {
                    var reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
                        results.Add(new CachedObject(reader));
                    }
                    reader.Close();
                }
            }
            return results;
        }

        /// <summary>
        /// Performs a non-query operation.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="sql"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.SqlClient.SqlException"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// You want to reseed MYTABLE to 1 using a parameter since this might be called many times with different values and you want the server to reuse execution plans.
        /// <c>Sql.ExecuteNonQuery("DBCC CHECKIDENT ('MYTABLE', RESEED, @value)", connectionStringFromSomewhere, Sql.Parameter("@value", 1));</c>
        /// </example>
        //No vulnerability here, the "sql" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review SQL queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static int ExecuteNonQuery(string cmdText, string connectionString, Parameters parameters = null, SqlTransaction transaction = null)
        {
            _sqlConnectionWithLock scwl = _sqlConnectionWithLock.Get(connectionString);
            SqlConnection c = scwl.Connection;
            lock (scwl.Lock)
            {
                using (SqlCommand cmd = new SqlCommand(cmdText, c).WithParameters(parameters))
                {
					if (transaction != null)
						cmd.Transaction = transaction;
                    return cmd.ExecuteNonQuery();
                }
            }
        }

        /// <summary>
        /// Executes a query and returns the result. If the result is not a single column/row it selects the first column of the first row.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="sql"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.SqlClient.SqlException"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// Get Vinh's user ID given a table called "User" with an int PK named "ID":
        /// <c>int vinhID = Sql.ExecuteScalar<int>("select ID from [User] where FirstName = 'Vinh' and LastName = 'Lam'", connectionStringFromSomewhere);</c>
        /// vinhID would contain Vinh's ID.
        /// </example>
        //No vulnerability here, the "sql" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review SQL queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static T ExecuteScalar<T>(string cmdText, string connectionString, Parameters parameters = null)
        {
            _sqlConnectionWithLock scwl = _sqlConnectionWithLock.Get(connectionString);
            SqlConnection c = scwl.Connection;
            lock (scwl.Lock)
            {
                using (SqlCommand cmd = new SqlCommand(cmdText, c).WithParameters(parameters))
                {
                    return (T)cmd.ExecuteScalar();
                }
            }
        }
        public static bool TestConnection(string connectionString)
        {
            _sqlConnectionWithLock scwl = _sqlConnectionWithLock.Get(connectionString);
            SqlConnection c = scwl.Connection;
            lock (scwl.Lock)
            {
                try
                {
                    if (c.State == ConnectionState.Closed)
                        c.Open();
                }
                catch (Exception e)
                {
                    e.ThrowIfNot<InvalidOperationException, SqlException>("Unexpected failure testing SQL connection.");
                    return false;
                }
                return true;
            }
        }

		public static class Interop
		{
			/// <summary>
			/// Returns a SqlParameter object for the single name/value combination provided.
			/// </summary>
			/// <param name="name"></param>
			/// <param name="value"></param>
			/// <returns></returns>
			public static SqlParameter Parameter(string name, object value)
			{
				return new SqlParameter(name, value);
			}

			public static SqlDataReader GetReader(string connectionString, string command, Parameters parameters = null)
			{
				_sqlConnectionWithLock scwl = _sqlConnectionWithLock.Get(connectionString);
				SqlConnection c = scwl.Connection;
				lock (scwl.Lock)
				{
					using (SqlCommand cmd = new SqlCommand(command, c).WithParameters(parameters))
					{
						return cmd.ExecuteReader();
					}
				}
			}

			public static SqlConnection GetConnection(string connectionString)
			{
				return _sqlConnectionWithLock.Get(connectionString).Connection;
			}
		}
    }
}
