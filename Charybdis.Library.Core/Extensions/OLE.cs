using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Data;
using System.Data.OleDb;
using System.Collections;

namespace Charybdis.Library.Core
{
    /// <summary>
    /// A wrapper around the standard .NET OLE library with nicer (more modern) syntax and extended functionality.
    /// </summary>
    //This class is generated by a combination of T4, DB.tt included within OLE.tt - do not edit it directly or your changes will be lost.
    public static partial class OleDb
    {
        public const string JET4 = "Microsoft.Jet.OLEDB.4.0";
        public const string ACE = "Microsoft.ACE.OLEDB.12.0";

        /// <summary>
        /// Represents an OLE connection with an object to lock onto to avoid blocking when multithreading.
        /// </summary>
        internal struct _oleConnectionWithLock
        {
            public OleDbConnection Connection;
            public object Lock;
            public ulong ConnectionsUsed;

            /// <summary>
            /// Create a new _oleConnectionWithLock (ignores the cache and does not add the new one to the cache).
            /// </summary>
            /// <param name="connectionString"></param>
            /// <returns></returns>
            public static _oleConnectionWithLock New(string connectionString)
            {
                _oleConnectionWithLock ocwl = new _oleConnectionWithLock
                {
                    Connection = new OleDbConnection(connectionString),
                    Lock = new object(),
                    ConnectionsUsed = 1,
                };
                return ocwl;
            }

            /// <summary>
            /// Get an _oleConnectionWithLock for a given connection string (tries to get an existing cached one first, caches any new ones it creates).
            /// </summary>
            /// <param name="connectionString"></param>
            /// <returns></returns>
            public static _oleConnectionWithLock Get(string connectionString)
            {
                _oleConnectionWithLock ocwl = _noOleDbConnectionWithLock;
                if (_connectionCache.ContainsKey(connectionString))
                    ocwl = _connectionCache[connectionString];
                else
                {
                    ocwl = _oleConnectionWithLock.New(connectionString);
                    _connectionCache.Add(connectionString, ocwl);
                }
                if (ocwl.Equals(_noOleDbConnectionWithLock))
                    throw new Exception("Failure to retrieve or create OLE connection.");
                else
                {
                    if (ocwl.Connection == null) //Shouldn't happen - just in case.
                    {
                        ocwl.Connection = new OleDbConnection(connectionString);
                        ocwl.Connection.Open();
                        ocwl.ConnectionsUsed++;
                    }
                    try
                    {
                        if (ocwl.Connection.State != ConnectionState.Open) //If it isn't open,
                            ocwl.Connection.Open(); //Make sure it is.
                    }
                    catch (Exception e) //Failed to open?
                    {
                        e.ThrowIfNot<
                            InvalidOperationException,
                            OleDbException,
                            System.Configuration.ConfigurationErrorsException
                            >("Failure to re-open existing OLE connection."); //If it's an odd reason, rethrow.
                        ocwl.Connection = new OleDbConnection(connectionString);
                        ocwl.Connection.Open();
                        ocwl.ConnectionsUsed++;
                    }
                    return ocwl;
                }
            }
        }

        /// <summary>
        /// Represents a non-entity of the type _oleConnectionWithLock.
        /// </summary>
        internal static _oleConnectionWithLock _noOleDbConnectionWithLock = new _oleConnectionWithLock { Connection = null, ConnectionsUsed = 0, Lock = null };

        /// <summary>
        /// Returns the connections used so far for a particular connection string.
        /// </summary>
        /// <param name="connectionString"></param>
        /// <returns></returns>
        public static ulong GetConnectionsUsed(string connectionString)
        {
            return _connectionCache[connectionString].ConnectionsUsed;
        }

        /// <summary>
        /// Storage location for connection reuse.
        /// </summary>
        private static Dictionary<string, _oleConnectionWithLock> _connectionCache = new Dictionary<string, _oleConnectionWithLock>();

        /// <summary>
        /// Represents a set of parameters to be used with an OLE query.
        /// </summary>
        public class Parameters : Dictionary<string, object>, IDictionary<string, object> {}

        /// <summary>
        /// Returns a Parameters object containing the single name/value combination provided.
        /// </summary>
        /// <param name="name"></param>
        /// <param name="value"></param>
        /// <returns></returns>
        /// <example>
        /// You want to pass a single parameter into a method from this library:
        /// <code>
        /// string fieldNameFromSomewhere = "ID";
        /// OleDb.Execute("select @field from MyTable", connectionStringFromSomewhere, OleDb.Parameter("@field", fieldNameFromSomewhere));
        /// </code>
        /// The way this works is equivalent to doing "new OleDbParameter(name, value)" with the regular API, except this library does not directly accept the underlying API's objects.
        /// </example>
        public static Parameters Parameter(string name, object value)
        {
            return new Parameters { { name, value } };
        }

        public class CachedObject
        {
            private Dictionary<string, object> _fields = new Dictionary<string, object>();
			public Dictionary<string, object> Fields
			{
				get
				{
					return _fields;
				}
			}

            /// <summary>
            /// Creates a CachedObject from an OleDbDataReader by reading all of the latter's fields into a Dictionary object.
            /// </summary>
            /// <param name="reader"></param>
            /// <exception cref="System.NotSupportedException"/>
            internal CachedObject(OleDbDataReader reader)
            {
                for (int i = 0; i < reader.FieldCount; i++)
                    _fields.Add(reader.GetName(i), reader.GetValue(i));
            }

            /// <summary>
            /// Create a CachedObject from an existing OleDbDataReader - used for interoperability with existing projects using the native OLE libraries.
            /// </summary>
            /// <param name="reader"></param>
            /// <returns></returns>
            public static CachedObject FromReader(OleDbDataReader reader)
            {
                return new CachedObject(reader);
            }

            /// <summary>
            /// Create list of CachedObject from an existing OleDbDataReader - used for interoperability with existing projects using the native OLE libraries.
            /// </summary>
            /// <param name="reader"></param>
            /// <returns></returns>
            public static List<CachedObject> ListFromReader(OleDbDataReader reader)
            {
                List<CachedObject> result = new List<CachedObject>();
                while (reader.Read())
                {
                    result.Add(new CachedObject(reader));
                }
                return result;
            }

            /// <summary>
            /// Retrieves a value-typed object from the CachedObject as the provided type.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="key"></param>
            /// <returns></returns>
            /// <exception cref="System.KeyNotFoundException"/>
            /// <example>
            /// Get a string named "LastName" from an object:
            /// <c>string lastName = myCachedObject.GetClass<string>("LastName");</c>
            /// </example>
            public T GetClass<T>(string key)
                where T : class
            {
                try
                {
                    return _fields[key] as T;
                }
                catch (KeyNotFoundException e) //The field isn't part of this object..
                {
                    throw new DataRetrievalException("The column \"" + key + "\" was not found on the object in CachedObject.GetClass<" + typeof(T).Name + ">(\"" + key + "\").", e);
                }
            }

            /// <summary>
            /// Retrieves a nullable struct from the CachedObject as the provided type.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="key"></param>
            /// <returns></returns>
            /// <exception cref="System.KeyNotFoundException"/>
            /// <example>
            /// Get an optional FK ID named "ResultID":
            /// <c>int? resultID = myCachedObject.GetNullable<int?>("ResultID");</c>
            /// </example>
            public T? GetNullable<T>(string key)
                where T : struct
            {
                try
                {
                    if (_fields[key] != DBNull.Value)
                        return (T)_fields[key];
                    else
                        return null;
                }
                catch (InvalidCastException) //The value isn't valid..
                {
                    return null;
                }
                catch (KeyNotFoundException e) //The field isn't part of this object..
                {
                    throw new DataRetrievalException("The column \"" + key + "\" was not found on the object in CachedObject.GetNullable<" + typeof(T).Name + ">(\"" + key + "\").", e);
                }
            }

            /// <summary>
            /// Retrieves a struct from the CachedObject as the provided type.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            /// <param name="key"></param>
            /// <returns></returns>
            /// <exception cref="System.KeyNotFoundException"/>
            /// <exception cref="System.InvalidCastException"/>
            /// <example>
            /// Get a PK named "ID" from an object:
            /// <c>int objectID = myCachedObject.GetStruct<int>("ID");</c>
            /// </example>
            public T GetStruct<T>(string key)
                where T : struct
            {
                try
                {
                    return (T)_fields[key];
                }
                catch (KeyNotFoundException e) //The field isn't part of this object..
                {
                    throw new DataRetrievalException("The column \"" + key + "\" was not found on the object in CachedObject.GetStruct<" + typeof(T).Name + ">(\"" + key + "\").", e);
                }
            }
        }

        //The below version of CachedObject uses a variation of a hackish trick found at 
        //https://codeblog.jonskeet.uk/2010/11/02/evil-code-overload-resolution-workaround/
        //it works and makes the API nicer, but it's bad practice stuff so I decided not
        //to use it in the name of readability and maintainability. -UdderlyEvelyn 9/9/16

        /*
        //This wrapper extension method is public, but leads to one of three static methods in CachedObject and its base (compile-time overload resolution).
        public static T Get<T>(this CachedObject co, string name)
        {
            return co.Get<T>(name);
        }

        public class CachedObject : _cachedObjectBase
        {
            public CachedObject(OleDbDataReader reader) : base(reader) {}

            //Class
            public class _classConstraint<T> where T : class { }
            internal T Get<T>(string key, _classConstraint<T> overloadTrickeryIgnoreThis = default(_classConstraint<T>))
                where T : class
            {
                return _fields[key] as T;
            }


            //Struct
            internal T Get<T>(string key, T? overloadTrickeryIgnoreThis = default(T?))
                where T : struct
            {
                return (T)_fields[key];
            }
        }

        public class _cachedObjectBase
        {
            protected Dictionary<string, object> _fields = new Dictionary<string, object>();
            internal _cachedObjectBase(OleDbDataReader reader)
            {
                for (int i = 0; i < reader.FieldCount; i++)
                    _fields.Add(reader.GetName(i), reader.GetValue(i));
            }

            //Nullable Struct
            internal T Get<T>(string key)
            {
                try
                {
                    return (T)_fields[key];
                }
                catch (InvalidCastException) //The value isn't valid..
                {
                    return default(T);
                }
            }
        }*/

        /// <summary>
        /// Convenience wrapper for AddWithParameter that adds the ability to specify DbType for the parameter.
        /// </summary>
        /// <param name="collection"></param>
        /// <param name="name"></param>
        /// <param name="value"></param>
        /// <param name="DbType"></param>
        /// <returns></returns>
        internal static OleDbParameter AddWithValue(this OleDbParameterCollection collection, string name, object value, DbType dbType)
        {
            OleDbParameter parameter = collection.AddWithValue(name, value);
            parameter.DbType = dbType;
            return parameter;
        }

        /// <summary>
        /// Fluent-style addition of parameters to an OleDbCommand
        /// </summary>
        /// <param name="command"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        internal static OleDbCommand WithParameters(this OleDbCommand command, Parameters parameters)
        {
            if (parameters != null)
                foreach (var p in parameters)
                    command.Parameters.AddWithValue(p.Key, p.Value ?? DBNull.Value);
            return command;
        }

        /// <summary>
        /// Returns a cached copy of an object retrieved from a query (takes the first object returned if multiple are found).
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ole"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.OleDbClient.OleDbException"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// Get the first user in a "User" table with an "ID" field for PK that starts at 1.
        /// <c>CachedObject user = OleDb.ExecuteObject("select top 1 from [User] where ID = 1", connectionStringFromSomewhere);</c>
        /// You can then access the user object's fields with the CachedObject class's methods regardless of whether the original connection has closed/etc..
        /// </example>
        //No vulnerability here, the "ole" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review OLE queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static CachedObject ExecuteObject(string cmdText, string connectionString, Parameters parameters = null)
        {
            CachedObject result = null;
            _oleConnectionWithLock ocwl = _oleConnectionWithLock.Get(connectionString);
            OleDbConnection c = ocwl.Connection;
            lock (ocwl.Lock)
            {
                using (OleDbCommand cmd = new OleDbCommand(cmdText, c).WithParameters(parameters))
                {
                    var reader = cmd.ExecuteReader();
                    //Load first row - set up a result if it exists.
                    if (reader.Read())
                        result = new CachedObject(reader);
                    reader.Close();
                }
                return result;
            }
        }

        /// <summary>
        /// Returns a string containing the results of the query in a format delimited by '\n' for each record, ',' for each column, and '☼' to separate column data.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ole"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.OleDbClient.OleDbException"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// <code>
        /// var results = OleDb.ExecuteString("select * from User where @activeTableName = @activeID", connectionStringFromSomewhere, 
        ///                               new Parameters
        ///                               {
        ///                                   { "@activeID", 1 }
        ///                                   { "@activeTableName", "LU_Active" }
        ///                               });
        /// </code>
        /// This would return a list of CachedObjects that contained the active users given that you had a lookup table called "LU_Active" with an ID of 1 meaning "active".
        /// </example>
        //No vulnerability here, the "ole" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review OLE queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static string ExecuteString(string cmdText, string connectionString, Parameters parameters = null)
        {
			StringBuilder sb = new StringBuilder();
            _oleConnectionWithLock ocwl = _oleConnectionWithLock.Get(connectionString);
            OleDbConnection c = ocwl.Connection;
            lock (ocwl.Lock)
            {
                using (OleDbCommand cmd = new OleDbCommand(cmdText, c).WithParameters(parameters))
                {
                    var reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
						for (int i = 0; i < reader.FieldCount; i++)
						{
							var value = reader.GetValue(i);
							sb.Append(reader.GetName(i) + '☼' + value + '☼' + value.GetType().FullName + (i == reader.FieldCount ? '\n' : ','));
						}
                    }
                    reader.Close();
                }
            }
            return sb.ToString();
        }

        /// <summary>
        /// Returns a list of cached copies of objects retrieved from a query.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ole"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.OleDbClient.OleDbException"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// <code>
        /// var results = OleDb.ExecuteList("select * from User where @activeTableName = @activeID", connectionStringFromSomewhere, 
        ///                               new Parameters
        ///                               {
        ///                                   { "@activeID", 1 }
        ///                                   { "@activeTableName", "LU_Active" }
        ///                               });
        /// </code>
        /// This would return a list of CachedObjects that contained the active users given that you had a lookup table called "LU_Active" with an ID of 1 meaning "active".
        /// </example>
        //No vulnerability here, the "ole" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review OLE queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static List<CachedObject> ExecuteList(string cmdText, string connectionString, Parameters parameters = null)
        {
            List<CachedObject> results = new List<CachedObject>();
            _oleConnectionWithLock ocwl = _oleConnectionWithLock.Get(connectionString);
            OleDbConnection c = ocwl.Connection;
            lock (ocwl.Lock)
            {
                using (OleDbCommand cmd = new OleDbCommand(cmdText, c).WithParameters(parameters))
                {
                    var reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
                        results.Add(new CachedObject(reader));
                    }
                    reader.Close();
                }
            }
            return results;
        }

        /// <summary>
        /// Performs a non-query operation.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ole"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.OleDbClient.OleDbException"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// You want to reseed MYTABLE to 1 using a parameter since this might be called many times with different values and you want the server to reuse execution plans.
        /// <c>OleDb.ExecuteNonQuery("DBCC CHECKIDENT ('MYTABLE', RESEED, @value)", connectionStringFromSomewhere, OleDb.Parameter("@value", 1));</c>
        /// </example>
        //No vulnerability here, the "ole" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review OLE queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static int ExecuteNonQuery(string cmdText, string connectionString, Parameters parameters = null, OleDbTransaction transaction = null)
        {
            _oleConnectionWithLock ocwl = _oleConnectionWithLock.Get(connectionString);
            OleDbConnection c = ocwl.Connection;
            lock (ocwl.Lock)
            {
                using (OleDbCommand cmd = new OleDbCommand(cmdText, c).WithParameters(parameters))
                {
					if (transaction != null)
						cmd.Transaction = transaction;
                    return cmd.ExecuteNonQuery();
                }
            }
        }

        /// <summary>
        /// Executes a query and returns the result. If the result is not a single column/row it selects the first column of the first row.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        /// <param name="ole"></param>
        /// <param name="connectionString"></param>
        /// <param name="parameters"></param>
        /// <returns></returns>
        /// <exception cref="System.InvalidOperationException"/>
        /// <exception cref="System.Data.OleDbClient.OleDbException"/>
        /// <exception cref="System.Configuration.ConfigurationErrorsException"/>
        /// <exception cref="System.InvalidCastException"/>
        /// <exception cref="System.IO.IOException"/>
        /// <example>
        /// Get Vinh's user ID given a table called "User" with an int PK named "ID":
        /// <c>int vinhID = OleDb.ExecuteScalar<int>("select ID from [User] where FirstName = 'Vinh' and LastName = 'Lam'", connectionStringFromSomewhere);</c>
        /// vinhID would contain Vinh's ID.
        /// </example>
        //No vulnerability here, the "ole" variable doesn't come from user input as the code analysis message mentions might be an issue.
        [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Security", "CA2100:Review OLE queries for security vulnerabilities", Justification = "False positive, no parameters directly from user input.")]
        public static T ExecuteScalar<T>(string cmdText, string connectionString, Parameters parameters = null)
        {
            _oleConnectionWithLock ocwl = _oleConnectionWithLock.Get(connectionString);
            OleDbConnection c = ocwl.Connection;
            lock (ocwl.Lock)
            {
                using (OleDbCommand cmd = new OleDbCommand(cmdText, c).WithParameters(parameters))
                {
                    return (T)cmd.ExecuteScalar();
                }
            }
        }
        public static bool TestConnection(string connectionString)
        {
            _oleConnectionWithLock ocwl = _oleConnectionWithLock.Get(connectionString);
            OleDbConnection c = ocwl.Connection;
            lock (ocwl.Lock)
            {
                try
                {
                    if (c.State == ConnectionState.Closed)
                        c.Open();
                }
                catch (Exception e)
                {
                    e.ThrowIfNot<InvalidOperationException, OleDbException>("Unexpected failure testing OLE connection.");
                    return false;
                }
                return true;
            }
        }

		public static class Interop
		{
			/// <summary>
			/// Returns a OleDbParameter object for the single name/value combination provided.
			/// </summary>
			/// <param name="name"></param>
			/// <param name="value"></param>
			/// <returns></returns>
			public static OleDbParameter Parameter(string name, object value)
			{
				return new OleDbParameter(name, value);
			}

			public static OleDbDataReader GetReader(string connectionString, string command, Parameters parameters = null)
			{
				_oleConnectionWithLock ocwl = _oleConnectionWithLock.Get(connectionString);
				OleDbConnection c = ocwl.Connection;
				lock (ocwl.Lock)
				{
					using (OleDbCommand cmd = new OleDbCommand(command, c).WithParameters(parameters))
					{
						return cmd.ExecuteReader();
					}
				}
			}

			public static OleDbConnection GetConnection(string connectionString)
			{
				return _oleConnectionWithLock.Get(connectionString).Connection;
			}
		}
    }
}
