<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ output extension=".cs" #>
using System;
using System.Linq;
using System.Collections.Generic;

namespace Charybdis.Library.Core
{
	/// <summary>
	/// Contains functions for processing data into other types of data, or performing generic/common actions on data - includes many convenience wrappers to make code more readable.
	/// </summary>
	public static class Numeric
	{
		public static Type[] Types = new[] { typeof(sbyte), typeof(byte), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong), typeof(float), typeof(double), typeof(decimal) };
		public static Type[] IntegerTypes = new[] { typeof(sbyte), typeof(byte), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong) };
		public static Type[] SignedIntegerTypes = new[] { typeof(sbyte), typeof(short), typeof(int), typeof(long) };
		public static Type[] UnsignedIntegerTypes = new[] { typeof(byte), typeof(ushort), typeof(uint), typeof(ulong) };
		public static Type[] FloatingPointTypes = new[] { typeof(float), typeof(double), typeof(decimal) };
		
		#region Missing Methods In .NET
<# 
System.Collections.Generic.Dictionary<Type, string> shortAliases = new System.Collections.Generic.Dictionary<Type, string>
{
	{ typeof(sbyte), "sbyte" },
	{ typeof(byte), "byte" },
	{ typeof(short), "short" },
	{ typeof(ushort), "ushort" },
};
foreach (var type in new[] { typeof(sbyte), typeof(byte), typeof(short), typeof(ushort) }) 
{
#> 
		//Methods For <#=type.Name#>

        /// <summary>
        /// Computes the sum of a sequence of <c><#=shortAliases[type]#></c> values.
        /// </summary>
        /// <param name="e"></param>
        /// <returns></returns>
        /// <exception cref="System.ArgumentNullException"/>
        /// <exception cref="System.OverflowException"/>
        public static <#=type.Name#> Sum(this IEnumerable<<#=type.Name#>> e)
        {
            return checked((<#=type.Name#>)e.Sum<<#=type.Name#>>(n => n));
        }

		//End Methods For <#=type.Name#>
<#
} 
#>

		#endregion

		#region Numeric Types
<# 
foreach (var type in new[] { typeof(sbyte), typeof(byte), typeof(short), typeof(ushort), typeof(int), typeof(long), typeof(float), typeof(double), typeof(decimal) }) 
{
#> 
        public static <#= type.Name #> DotProduct(this <#= type.Name #>[] a1, <#= type.Name #>[] a2)
        {
            if (a1.Length != a2.Length)
                throw new InvalidOperationException("The two arrays must be of equal length to form a valid dot product.");
            return a1.Zip<<#=type.Name#>, <#=type.Name#>, <#=type.Name#>>(a2, (n1, n2) => checked((<#=type.Name#>)(n1 * n2))).Sum();
        }

		public static <#= type.Name #> Wrap(this <#= type.Name #> value, <#= type.Name #> delta, <#= type.Name #> min, <#= type.Name #> max)
        {
            var nv = value + delta;
            if (nv > max)
                nv -= max;
            else if (nv < min)
                nv += max;
            return (<#= type.Name #>)nv;
        }
<#
} 
#>

		#endregion

		#region Integers (Signed & Unsigned)
<# 
foreach (var type in new[] { typeof(sbyte), typeof(byte), typeof(short), typeof(ushort), typeof(int), typeof(uint), typeof(long), typeof(ulong) }) 
{ 
#>

		//Methods For <#=type.Name#>

		//This method is generated by a template in Numeric.tt - be sure to edit it there and keep in mind that it affects multiple numeric types.
		/// <summary>
		/// Get the digit count of an integer.
		/// </summary>
		/// <param name="i"></param>
		/// <returns></returns>
		//We are using a bunch of nested conditions instead of a loop for performance reasons. - UdderlyEvelyn
		public static int GetDigitLength(this <#= type.Name #> i)
		{
			if (i > 9) //More than 1 digit?
				if (i > 99) //More than 2 digits?
<#
if (type.Name != "Byte" && type.Name != "SByte")
{
#>
					if (i > 999) //More than 3 digits?
<#
if (type.Name != "Int16")
{
#>
						if (i > 9999) //More than 4 digits?
<#
if (type.Name != "UInt16")
{
#>
							if (i > 99999) //More than 5 digits?
								if (i > 999999) //More than 6 digits?
									if (i > 9999999) //More than 7 digits?
										if (i > 99999999) //More than 8 digits?
<#
if (type.Name != "Int32")
{
#>
											if (i > 999999999) //More than 9 digits?
<#
if (type.Name != "UInt32")
{
//This block affects UInt32, Int64, UInt64.. For some reason UInt64 isn't one digit longer than Int64, unlike the other integer pairs.
#>
												if (i > 9999999999) //More than 10 digits?
													if (i > 99999999999) //More than 11 digits?
														if (i > 999999999999) //More than 12 digits?
															if (i > 9999999999999) //More than 13 digits?
																if (i > 99999999999999) //More than 14 digits?
																	if (i > 999999999999999) //More than 15 digits?
																		if (i > 9999999999999999) //More than 16 digits?
																			if (i > 99999999999999999) //More than 17 digits?
																				if (i > 999999999999999999) //More than 18 digits?
																					return 19; //Max for long/ulong, which is the largest this method supports.
																				else
																					return 18;
																			else
																				return 17;
																		else
																			return 16;
																	else
																		return 15;
																else
																	return 14;
															else
																return 13;
														else
															return 12;
													else 
														return 11;
												else
<#
Write("\t");
}
#>
												return 10;
											else
<#
Write("\t");
}
#>
											return 9;
										else
											return 8;
									else
										return 7;
								else
									return 6;
							else
<#
Write("\t");
}
#>
							return 5;
						else
<#
Write("\t");
}
#>
						return 4;
					else
<#
Write("\t");
}
#>
					return 3;
				else
					return 2;
			else
				return 1;
		}
		
		//End Methods For <#=type.Name#>
<#
} 
#>

		#endregion
		
		#region Integers (Signed Only)
<# 
foreach (var type in new[] { typeof(sbyte), typeof(short), typeof(int), typeof(long) }) 
{ 
#>

		//Methods For <#=type.Name#>

		//End Methods For <#=type.Name#>
<#
}
#>

		#endregion

		#region Integers (Unsigned Only)
<# 
foreach (var type in new[] { typeof(byte), typeof(ushort), typeof(uint), typeof(ulong) }) 
{ 
#>

		//Methods For <#= type.Name#>

		//End Methods For <#=type.Name#>
<#
}
#>

		#endregion

		#region Floating Point
<# 
foreach (var type in new[] { typeof(float), typeof(double), typeof(decimal) }) 
{ 
#>

		//Methods For <#= type.Name#>

		//End Methods For <#=type.Name#>
<#
}
#>

		#endregion
	}
}